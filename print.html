<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>clientside</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="montgomery_multiplication.html"><strong aria-hidden="true">2.</strong> Montgomery multiplication</a></li><li class="chapter-item expanded "><a href="credits.html"><strong aria-hidden="true">3.</strong> Credits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">clientside</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="clientside-optimising-client-side-zk-in-wasm"><a class="header" href="#clientside-optimising-client-side-zk-in-wasm"><code>clientside</code>: Optimising Client-Side ZK in WASM</a></h1>
<p>Privacy-preserving applications of zero-knowledge proofs typically rely on
protocols that use large-prime field and elliptic curve arithmetic. These
operations, however, are computationally intensive for consumer devices,
leading to latency and therefore subpar user experiences. Moreover, it is
unacceptable to outsource proof generation to a third-party server since this
would expose private user data. As such, it is important to optimise the
algorithms and techniques for client-side proof generation.</p>
<p>Significant progress in this area has emerged from the <a href="https://www.zprize.io">ZPrize
competition</a> organised by <a href="https://aleo.org/">Aleo</a> and
others. Submissions to this competition include accelerated code for <a href="https://www.zprize.io/blog/announcing-zprize-results">elliptic
curve and finite field
arithmetic</a>, as well as
speeding up the <a href="https://www.zprize.io/blog/announcing-the-2023-zprize-winners">multi-scalar multiplication
algorithm</a> in
the browser using technologies such as WASM and WebGPU. All of this work has
been open-sourced, and anyone can adopt these optimisations.</p>
<p>Yet, there are still some gaps: some techniques are not fully documented, and
engineers need to look up various academic papers and dissect complicated code
in order to understand how they work. Furthermore, while benchmarks of the
contest submissions were performed by the ZPrize judges, benchmarks of
individual techniques, such as different ways to perform Montgomery
multiplication, have not yet been done.</p>
<p>The goal of this project is to address these issues. This document and
repository aims to help software engineers get up to speed with highly optmised
client-side cryptography. To start with, this document will provide detailed
explanations of optimised Montgomery multiplication algorithms for large prime
fields, as well as their associated benchmarks. In the future, this document
will cover more topics, such as but not limited to optimistions for elliptic
curve operations, multi-scalar multiplication, and fast Fourier transforms.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="montgomery-multiplication"><a class="header" href="#montgomery-multiplication">Montgomery multiplication</a></h1>
<p>When one has to perform a large number of field multiplications starting out
from a relatively small number of input field elements, it is much more
efficient to use Montgomery modular multiplication than to perform regular
multiplication and modular reduction at each step.</p>
<p>Montgomery modular multiplication operates on inputs which are already in
<em>Montgomery form</em> (i.e. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span> where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> are coprime),
and outputs <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span>). <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>, and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> are multiprecision values, also
known as big integers, with <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> limbs of at most <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> bits. In code, each
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>-bit limb is typically stored in a 32 or 64-bit unsigned integer or
floating-point data type. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is typically <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, and must be coprime to
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>.</p>
<pre class="mermaid">graph LR
    A[&quot;a&quot;] --&gt; B[&quot;MontMul(a, R^2) = aR&quot;]:::montmul
    B --&gt; D[&quot;MontMul(aR, aR) = aaR&quot;]:::montmul
    D --&gt; E[...]:::montmul
    E --&gt; F[&quot;MontMul((a^e)R, 1) = a^e&quot;]:::montmul
    F --&gt; G[&quot;a^e&quot;]

    classDef montmul font-weight:bold
</pre>
<p>To illustrate how this would work on the abovementioned exponentiation example,
where we wish to efficiently compute <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span>, we would first compute
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span> (using <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0719em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">MontMul</span><span class="mopen">(</span><span class="mord mathsf">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathsf">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8219em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathsf mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>), perform <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> Montgomery
multiplications, and then convert the result <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> out of Montgomery form by
computing <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathsf">MontMul</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathsf">MontMul</span></span></span></span></span> is a combination of two algorithms: multiplication and
reduction. In practice, these algorithms are merged, but in gain intuition
about how it works, it is key to understand how Montgomery reduction works.</p>
<p>The Montgomery reduction algorithm is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Description</th><th>Restrictions</th></tr></thead><tbody>
<tr><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></td><td>The field modulus.</td><td>Must be odd.</td></tr>
<tr><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></td><td>The value to reduce.</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td></tr>
<tr><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></td><td>The Montgomery radix.</td><td>Coprime to and greater than <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>. Must be a power of 2, usually <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span></span></span></span> is the limb size multiplied by the number of limbs.</td></tr>
<tr><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span></td><td>The precomputed Montgomery constant.</td><td><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, computed using the extended Euclidian algorithm.</td></tr>
</tbody></table>
</div>
<p>The output is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span>. As long as the input <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, Montgomery reduction computes <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span> as desired.</p>
<p>Crucially, we assume that division by <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is efficient. In computer processors,
this is true as long as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is a power of 2, since said division can be done
simply via bitshifts.</p>
<p>The steps of the algorithm are:</p>
<ol>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μx</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">pq</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li>
<li>If <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> then <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>.</li>
<li>Return <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</li>
</ol>
<p>Substituting <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span> in step 1, we have <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span></span></span></span>. When we multiply
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> by <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> in step 2, the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> terms cancel each other out,
leaving us with some nonzero value equivalent to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> in the integer
domain. Next, dividing by <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is equivalent to multiplying by <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>, giving
us our result <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>. A final subtraction (step 3) may be needed to
bring <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> to the desired range <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>.</p>
<p>Addition and subtraction of values in Montgomery form work as per usual due to
the <a href="https://en.wikipedia.org/wiki/Distributive_property">distributive law</a>:</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></p>
<p>A fuller description of the above steps can be found in <a href="https://eprint.iacr.org/2017/1057.pdf"><em>Montgomery Arithmetic
from a Software Perspective</em></a> by Joppe
Bos (section 2), including a proof that only one conditional subtraction is
needed (p4).</p>
<p>There are several variants of the Montgomery modular multiplication algorithm,
and they perform differently depending on the platform. Since we target WASM in
the browser, we will focus on those which are most suitable for it. We will
cover:</p>
<ul>
<li><strong>Emmart's method</strong>: using 64-bit floating point variables and single
instruction, multiple data (SIMD) opcodes.</li>
<li><strong>Mitscha-Baude's method</strong>: using 64-bit unsigned integers to store
reduced-radix limbs, namely 29 or 30-bit limbs. This method can also be
adapted to work in in 32-bit environments for 13-bit limbs, <a href="https://github.com/td-kwj-zp2023/webgpu-msm-bls12-377/blob/bls12_377/README.md#montgomery-multiplication">such as
WebGPU</a>.</li>
</ul>
<h2 id="existing-literature"><a class="header" href="#existing-literature">Existing literature</a></h2>
<p>Before we describe these methods, we encourage the reader to review existing
work on Montgomery multiplication.</p>
<h3 id="peter-montgomerys-original-paper"><a class="header" href="#peter-montgomerys-original-paper">Peter Montgomery's original paper</a></h3>
<p><a href="https://www.ams.org/journals/mcom/1985-44-170/S0025-5718-1985-0777282-X/S0025-5718-1985-0777282-X.pdf"><em>Modular Multiplication Without Trial
Division</em></a>
(1985) is the seminal paper introducing Montgomery reduction.</p>
<h3 id="tolga-acars-thesis"><a class="header" href="#tolga-acars-thesis">Tolga Acar's thesis</a></h3>
<p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1996/01/j37acmon.pdf"><em>Analyzing and Comparing Montgomery Multiplication
Algorithms</em></a>
(1996) by Tolga Acar, et al, provides line-by-line algorithms for Montgomery
multiplications, along with a complexity analysis. Of the five algorithms it
describes, the Coarsely Integrated Operand Scanning (CIOS) method is most often
implemented, likely due to its relatively lower time and space complexity.</p>
<p>The Separated Operand Scanning (SOS) method, however, should be considered as a
potentially more performant Montgomery squaring algorithm, even if it requires
more space to store the intermediate results. Since it performs the
multiplication before reduction, about half of of the term multiplications can
be skipped (p6). More benchmarks are needed to validate this claim.</p>
<p>Each of these methods require the precomputed most significant limb of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, sometimes referred to as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span> or <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">n</span><span class="mord">0</span></span></span></span>. It performs the same role as
step 1 of the high-level Montgomery multiplication algorithm to cancel out the
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> term (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μx</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>) as described above, except that it
operates in the multiprecision context.</p>
<p><a href="https://eprint.iacr.org/2017/1057.pdf"><em>Montgomery Multiplication from a Software
Perspective</em></a> (2017) by Joppe Bos
provides a version of the Montgomery multiplication algorithm that is suitable
for SIMD-enabled processors. An implementation in C for ChromeOS firmware can
be found in the <a href="https://github.com/coreboot/vboot/blob/main/firmware/2lib/2modpow_sse2.c">vboot
repository</a>.
It is, unfortunately, not suitable for WASM in the browser, as it requires
certain SIMD opcodes (such as unsigned 64-bit x 2 multiplication) which
browsers do not execute using native CPU SIMD instructions. Rather, they unpack
these variables and repack them, leading to unnecessary overhead. This is in
contrast to Emmart's method, which uses 64-bit x 2 floating-point
multiply-and-add (FMA) SIMD instructions, which <em>do</em> get natively executed
under the hood.</p>
<h2 id="emmarts-method"><a class="header" href="#emmarts-method">Emmart's method</a></h2>
<p>Niall Emmart's submission to ZPrize 2023 contains a Montgomery multiplication
algorithm based on the <code>f64x2_relaxed_madd</code> relaxed SIMD WASM opcode. Each
field element is an arrays of <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">64-bit floating point
variables</a>.
Each mantissa of these values holds a 51-bit limb. This technique draws upon
his paper <a href="https://ieeexplore.ieee.org/document/8464792/"><em>Faster Modular Exponentiation Using Double Precision Floating Point
Arithmetic on the GPU</em></a> (EZW18)
but uses 51 instead of 52 bits per limb as the developer cannot control the
opcode's rounding mode.</p>
<p>As mentioned earlier, web browsers only translate some WASM SIMD instructions
(see https://emscripten.org/docs/porting/simd.html#optimization-considerations)
into native SIMD opcodes. As such, Emmart's method outperforms the
corresponding algorithm by Bos (2017) mentioned above.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>The key building block of Emmart's method is how it computes the product of two
51-bit limbs <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>. The result are two 51-bit values: a high term and a
low term (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathsf">hi</span></span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathsf">lo</span></span></span></span></span>).</p>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathsf">hi</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathsf">lo</span></span><span class="mclose">)</span></span></span></span></p>
<p>Each limb and term are stored in an 64-bit floating point data type defined by
the IEEE-754 standard (which we will refer to as <code>f64</code>s).</p>
<p>Required operations on <code>f64</code>s are as follows. Note that we do not assume that
the developer has control over the rounding mode of any of these operations
(although EZW18 uses a FMA operation <code>__fma_rz</code> which always rounds to zero).</p>
<ul>
<li><code>mul_add</code>: Fused multiply and add, such as the <code>mul_add</code> function in Rust, or
<code>__fma_rz</code> function in CUDA. We assume that the multiplication occurs with
infinite precision, and that rounding occurs at the addition step.</li>
<li><code>-</code>: Subtraction.</li>
<li><code>to_u64()</code> or <code>f64::to_bits()</code>: Conversion to IEEE-754 formatted bits. In C,
one can use a <code>memcpy</code> to do this conversion.</li>
</ul>
<p>By the IEEE-754 standard, 64-bit floating-point values have the following bit
layout:</p>
<pre><code>[1-bit sign][11-bit exponent][52-bit mantissa]
</code></pre>
<p>The exponent has a bias of 1023 (to obtain its absolute value, subtract 1023).</p>
<p>For clarity, we will use this format to display <code>f64</code>s: <code>(sign, unbiased exponent, mantissa in hex)</code>. For example, the <code>f64</code> <code>(0, 103, 0A8C3F0EB9985)</code>
is positive because its sign bit is 0, has an exponent of <code>1126 - 1023 = 103</code>,
and has a mantissa of <code>0x0A8C3F0EB9985</code>.</p>
<h3 id="the-algorithm"><a class="header" href="#the-algorithm">The algorithm</a></h3>
<p>First, we define some constants:</p>
<ul>
<li><code>c1</code> is a <code>f64</code> with the value <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">103</span></span></span></span></span></span></span></span></span></span></span></span>.
<ul>
<li>In our format, it is: <code>(0, 103, 0x0000000000000)</code>.</li>
<li>In hexadecimal, it is <code>0x4660000000000000</code>.</li>
</ul>
</li>
<li><code>c2</code> is a <code>f64</code> with the value <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">103</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">51</span></span></span></span></span></span></span></span></span></span></span></span>.
<ul>
<li>In our format, it is: <code>(0, 103, 0x0000000000003)</code>.</li>
<li>In hexadecimal, it is <code>0x4660000000000003</code>.</li>
</ul>
</li>
</ul>
<p>Next, we compute the floating points <code>hi</code>, <code>sub</code>, and <code>lo</code>:</p>
<pre><pre class="playground"><code class="language-rust!"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut hi = a.mul_add(b, c1);
let sub = c2 - hi;
let mut lo = a.mul_add(b, sub);
<span class="boring">}</span></code></pre></pre>
<p>Next, we subtract <code>c1</code> from <code>to_u64(hi)</code>. This is effectively the same as
applying a bitmask, but allows for a large number of product terms to be summed
and then a single subtraction to be performed, instead of applying a bitmask
every time we compute a product (EZW18 p131).</p>
<pre><pre class="playground"><code class="language-rust!"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut hi = hi.to_bits() - c1.to_bits();
<span class="boring">}</span></code></pre></pre>
<p>Finally, we perform a conditional subtraction on the high bits, mask the low
bits, and return the results.</p>
<pre><pre class="playground"><code class="language-rust!"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lo = lo.to_bits() &amp; mask;
// If the lower word is negative, subtract 1 from the higher word
if lo &amp; 0x4000000000000u64 &gt; 0 {
    hi -= 1;
}

return (hi, lo);
<span class="boring">}</span></code></pre></pre>
<p>Also note that this subtraction may be omitted if the multiprecision arithmetic
algorithm you use performs carry propagation.</p>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>When we perform:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut hi = a.mul_add(b, c1);
<span class="boring">}</span></code></pre></pre>
<p>What occurs behind the scenes is:</p>
<ol>
<li>Computation of <code>a * b</code> with infinite precision, which will have an exponent
of at most 51 * 2 = 102.</li>
<li>Addition of <code>c1 = (0, 103, 0x0000000000000)</code> to <code>a * b</code>, which forces the
result to have an exponent of 103, and a 52-bit mantissa of bits 52-103.</li>
<li>During the addition step, the result is rounded up if the 51st bit is 1, and
not rounded up if it is 0.</li>
</ol>
<p>Let's visualise this with example values <code>a = 1596695558896492</code> and <code>b = 1049164860932151</code>.</p>
<p>The binary representation of the full (non-floating-point) product of <code>a * b + c1</code> is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>╭╴ 104 
10011110111010110001...10111011010010101001...1 
╰─ The top 52 bits ────╯╰── Lower 51 bits ───╯╰─ The rounding bit (51) 
<span class="boring">}</span></code></pre></pre>
<p>Compare the above with the binary representation of the mantissa of the
floating-point value <code>hi = a.mul_add(b, c1)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>01000110011000111101110101100010110110...11 
│╰─ e=103──╯╰── mantissa (rounded up) ────╯ 
╰╴ Sign (positive)                     52 ╯
<span class="boring">}</span></code></pre></pre>
<p>Observe that the mantissa of <code>hi</code> is greater by 1. This is because the CPU
rounds this floating point value up as the 51st bit is 1.</p>
<p>To understand how we get the lower 52 bits, let us expand the computation of
<code>sub</code> and <code>lo</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sub = c2 - hi; let mut lo = a.mul_add(b, sub); 
<span class="boring">}</span></code></pre></pre>
<p><code>sub</code> is negative, and contains the high bits. Subtracting <code>sub</code> from <code>a * b</code>
zeros out the high bits, forces the exponent to 52, and leaves us with the
lower 52 bits.</p>
<pre><code>(a * b) + sub                     =
(a * b) + (c2              ) - hi =
(a * b) + (2^103 + 3 * 2^51) - hi
   │             │           ╰─ Subtracts the high bits and 2^103 from c2
   │             ╰─ Sets the exponent of the result to 52, and sets bit 52 to 1
   ╰─ Computes a * b with full precision (102 bits)
</code></pre>
<p>All that is left is to subtract 1 from <code>hi</code> if the leftmost (51st) bit of <code>lo</code>
is 1, and apply a bitmask to <code>lo</code> to ensure that we only have the lower 51
bits.</p>
<h3 id="finite-field-implementation"><a class="header" href="#finite-field-implementation">Finite Field Implementation</a></h3>
<p>Next, Emmart's method incorporates the abovementioned FMA-based limb product
algorithm into CIOS Montgomery multiplication. This can be seen in his
<code>fieldPairMul()</code> code in
<a href="https://github.com/z-prize/2023-entries/blob/main/prize-2-msm-wasm/prize-2b-twisted-edwards/yrrid-snarkify/yrrid/FieldPair.c">FieldPair.c</a>.
The implementation references <strong>algorithm 9</strong> in
<a href="https://ieeexplore.ieee.org/document/8464792/">EZW18</a>, but works in a single
thread.</p>
<p>To understand how it works, read it along with the following notes:</p>
<ul>
<li><strong>Extracting high and low terms</strong>: The constants <code>c0</code> to <code>c4</code> are used to
extract the high and low terms, as described above.</li>
<li><strong>Hardcoded modulus</strong>: The limbs of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> are hardcoded in <code>p[]</code>.</li>
<li><strong>Initial values of <code>sum[]</code></strong>: As described in EZW18 (p133), the initial
values of the <code>sum</code> array are carefully constructed so that they get
cancelled out by the first 12 bits of each term accumulated by the CIOS
algorithm.</li>
<li><strong>Lack of carry propagation or a final conditional subtraction</strong>:
<code>fieldPairMul()</code> does not perform carry propagation, but carries can be
resolved by the parent function by calling
<a href="https://github.com/z-prize/2023-entries/blob/main/prize-2-msm-wasm/prize-2b-twisted-edwards/yrrid-snarkify/yrrid/FieldPair.c#L111"><code>fieldPairResolve()</code></a>.
Additionally,<code>fieldPairMul()</code> does not perform a conditional subtraction;
rather, the parent function is responsible for invoking either
<code>fieldPairReduce()</code> (which can reduce a big integer between <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">6</span><span class="mord mathnormal">p</span></span></span></span> to
modulo <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>, albeit with some exceptions), or <code>fieldPairFullReduceResolve()</code>
which ensures that a reduction is performed. The reason for unbundling the
reduction and carry propagation is to optimise elliptic curve operations, by
performing a conditional subtraction after some number of field
multiplications, rather than after every single one.</li>
</ul>
<h2 id="mitscha-baudes-method"><a class="header" href="#mitscha-baudes-method">Mitscha-Baude's method</a></h2>
<p>Gregor Mitscha-Baude's submission to ZPrize 2022 uses reduced-radix big integer
representation (29 or 30 bits), along with a custom Montgomery multiplication
algorithm that minimises bitshifts. This allows his code to outperform the
classic CIOS method which uses 32-bit limbs. He provides a full description of
his method in his <a href="https://github.com/mitschabaude/montgomery/blob/main/doc/zprize22.md#13-x-30-bit-multiplication"><code>montgomery</code>
repository</a>.</p>
<p>The key insight is that 32-bit limbs require a carry after every product, which
involves an addition, a bitwise AND, and a bitshift. If, however, smaller limbs
are used, multiple products can be done without carries. For 29-bit limbs, that
number is 64, and 16 for 30-bit limbs. A further minor optimisation is that
based on the limb size, some conditional branches can be omitted from
Mitscha-Baude's algorithm.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>The following benchmarks were made on a 13th Gen Intel(R) Core(TM) i7-13700HX
laptop running the following algorithm, which executes <code>cost</code> Montgomery
multiplications. Since each loop iteration depends on the previous one, the
multiplications run in serial.</p>
<pre><code class="language-rs">fn expensive_function(ar, br, p, n0, cost){
    x = a
    y = b
    for _ in 0..cost {
        z = mont_mul(x, y, p, n0)
        x = y
        y = z
    }
    return y
}
</code></pre>
<p>The coded being benchmarked was written in C and compiled to WASM using
Emscripten. It lives in the <a href="https://github.com/weijiekoh/clientside/"><code>clientside</code>
repository</a>.</p>
<p>The following versions of Montgomery multiplication were benchmarked:</p>
<ul>
<li>CIOS from Bos (2017), without SIMD opcodes</li>
<li>CIOS from Bos (2017), with SIMD opcodes</li>
<li>CIOS from Acar (1996)</li>
<li>CIOS with Emmart's method</li>
<li>Mitscha-Baude's method (29-bit limbs)</li>
<li>Mitscha-Baude's method (30-bit limbs)</li>
</ul>
<p>For <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> Montgomery multiplications, the performance was:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Time taken (ms)</th></tr></thead><tbody>
<tr><td>Bos (2017) without SIMD</td><td>76</td></tr>
<tr><td>Bos (2017) with SIMD</td><td>110</td></tr>
<tr><td>Acar (1996)</td><td>73</td></tr>
<tr><td>Emmart's method</td><td>20</td></tr>
<tr><td>Mitscha-Baude's method (29-bit limbs)</td><td>13.8</td></tr>
<tr><td>Mitscha-Baude's method (30-bit limbs)</td><td>13.9</td></tr>
</tbody></table>
</div>
<p>For <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> Montgomery multiplications, the performance was:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Time taken (ms)</th></tr></thead><tbody>
<tr><td>Bos (2017) without SIMD</td><td>4.9</td></tr>
<tr><td>Bos (2017) with SIMD</td><td>6.9</td></tr>
<tr><td>Acar (1996)</td><td>4.6</td></tr>
<tr><td>Emmart's method</td><td>1.2</td></tr>
<tr><td>Mitscha-Baude's method (29-bit limbs)</td><td>0.9</td></tr>
<tr><td>Mitscha-Baude's method (30-bit limbs)</td><td>0.9</td></tr>
</tbody></table>
</div>
<p>Note that Bos' method with SIMD instructions is significantly slower than the
equivalent version without SIMD instructions, while Mitscha-Baude's method was
faster than Emmart's.</p>
<p>These benchmarks should not be taken as definitive because more work should be
done to further optimise them. At the time of writing, inline assembly was not
used, although a future version of these benchmarks should do so.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="credits"><a class="header" href="#credits">Credits</a></h1>
<p>Koh Wei Jie (<a href="https://github.com/weijiekoh">contact@kohweijie.com</a>) and Tal Derei (<a href="https://github.com/TalDerei">tal@penumbralabs.xyz</a>) contributed to this document. Please reach out to us if you would like to contribute.</p>
<p>We are grateful to the respective authors of each algorithm described. We also thank the ZPrize organisers and judges for making this work possible. We also thank Kobi Gurkan and Guillermo Angeris for their valuable feedback.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
